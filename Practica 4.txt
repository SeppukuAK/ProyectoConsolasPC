11 - 25

------Práctica 4--------------
leer anchura y altura en big endian --> darles la vuelta con desplazamiento de bits, usando codigo condicional (ifdef) para hacer la transformacion. SDL ayuda con eso para ver si es big o little endian

En PS4 como se da la vuelta? con desplazamiento de bits y con ands

	c = (c>> 24) | c >> 16 & 0xFF00(8 bits bajos)

------------------------------------12 - 2-----------------------------------------------

Input:

PS4:
Hay usuarios en la propia consola. Siempre tienes que decir quién eres. 

En el mando en el que hacemos login. Todos los logros que consigamos estan asociados a ese usuario.

Todo va por usuarios y no por mandos.
El juego te pide la información de entrada del usuario. Y si el usuario no tiene mando pues te da la informacion de que está en reposo.

Se gestiona la entrada a traves de lo usuarios.
Puede haber usuarios invitados.
Como mucho hay 16 usuarios locales.

Hay que mirar que usuarios estan logeados
Quedarnos con el primero
Abrir un puerto

Leemos la informacion de ese dispositivo

Hacemos un seguimiento de si se conectan nuevos usuarios

Y cuando terminemos pues cerramos todos.

El estado del mando se puede saber, excepto del boton playStation.

El mando PS4 tiene altavoz.

Existe un usuario Generico pero que no vamos a usar.

Vamos a usar el mando del primer usuario y ya está.


El proceso es:
1. Abrir la libreria de usuario:
	-userservicelibrary
		-incluir un .h user_service.h
		-libSceUserService_stub_weak.a -> Meterlo en la compilacion para Orbis
		-#pragma comment(lib,"Nombre de la libreria entre comillas"); -> Indicaciones que se llaman al compilador -> Aunque esto va al enlazador -> Añade la libreria (solo en un .cpp) -> Esta opcion me parece feisima.

		-Hacer uso del API.
			-SceUserServiceUserId -> Es un tipo. ID del jugador
			-sceUserServiceInitialize(NULL); -> Inicializa la libreria de gestión de usuarios. Imprescindible ponerlo. -> Crea una hebra del sistema que monitoriza los usuarios que se conectan y desconectan.
			-Hay que saber quién ha lanzado el juego: sceUserServiceInitialUser(&userId); //Recibe un * a un SceUserServiceUserId
			-Ahora podremos coger el mando asociado a ese usuario.
			-sceUserServiceTerminate(); -> Cierra la libreria de usuarios. Se carga la hebra.
			-En esta practica podemos cerrarlo en el momento en que conseguimos el ID del usuario. No necesitamos nada mas de gestion de usuarios, la hace directamente la consola por nosotros.
			-EJEMPLO: common\include\sampleutils\system.h -> Este codigo confunde mas que ayuda.
				-y ejemplo implementado 3 veces. Para ps4, psvita y pc.



		-TRC. Test que todo juego tiene que pasar.
		-Se le puede decir a la play que el juego es monojugador. Hay que decirselo en esta práctica. El juego empieza desde el principio cuando se cambia de jugador.
		-Hay que consiguir acceso al manejador de la entrada

2. Input.
	-PAD Library. Nos da el acceso a la información de los mandos
		-pad.h
		-libScePad_stub_weak.a
		-Hay un ejemplo muy completo de la entrada del mando. La parte de pintado es una fiesta. Pero la parte de detectar la entrada es interesante.
		-scePadInit(); --> Hay muchas mas funciones que hay que mirar en el ejemplo.
		-handle = scePadOpen(userId,SCE_PAD_PORT_TYPE_STANDART,0,nullptr);	//El enum es para el tipo de dispositivo (move, volante, vr etc.) -> Esto nos da un manejador de dispositivo virtual. Del cual podemos obtener su estado.
		-scePadClose(handle); --> Cierra el manejador. Esto es necesario en un juego multijugador. Aunque hay que meterlo en el cierre.
		-Entre el open y close hay que detectar el estado del mando
		-TIENE QUE HABER UNA CLASE DE ENTRADA.
		-Tick se procesa la entrada.
		-ScePadData. Estado del mando.
		-scePadReadState(-). Recibirá el manejador y un puntero a un ScePadData.
		-scePadRead() -> La diferencia está en que nos da las diferencias con la ultima vez que lo llamamos. 
		-Tiramos de ReadState() no deberia haber problemas.
		-Si necesitamos un seguimiento fino como el giroscopio o acelerometro usuariamos read.
		-AMIGUI HOLA QUIEREME.
		-AMIGUI HASTA QUE NO VEAS ESTO NO ME QUIERES.
		-hay que utilizar solo una vez: scePadGetControllerInformation(); recibe el manejador y un puntero a una estructura.
			-La utilidad es conseguir la información de las DEAD ZONES. (ZONAS DONDE SE IGNORA EL JOYSTICK)
		-En SCE PAD DATA hay un monton de booleanos con los botones.
		-los joystick nos dan un byte.
		-los L2 Y R2 No tienen zona muerta. Es un byte. 0x00 es reposo 0xFF es maximo
		-La logica discretiza el estado de los gatillos no la plataforma.
		-En neiborhood. Mando en pantalla o mando host controller. Hay que marcar host controller antes de hacer el view. Hay que hacerlo con el fisico.


SDL:

Tenemos 2 gatillos en el mando. No es una metralleta. Para que deje de ser disparo los 2 gatillos tienen que estar sueltos. Hay que convertirlos de analogico a digital.

-Tiene que haber un deltaTime.

el joystick izquierdo derecho va desde -1.0 a 1.0. Tiene que haber zonas muertas
-0.8 a -0.2 , 0.2 a 0.8 son zonas muertas

gatillo:
-1.0 a 1.0
	-1.0 reposo
	a la ida y ala vuelta del trigger hay distintos deadzones de on y off.


	------------------------------------------------------------------------
	Cositas para adri:
	https://wiki.libsdl.org/SDL_Event					SDL_Event
	https://wiki.libsdl.org/SDL_GameControllerAxis		SDL_GameControllerAxis


	SDL_GameController is an abstraction for gamepads ("controllers") similar to the xbox360-pad: They have a DPAD, two analog sticks, 4 buttons on the right (often called A, B, X, Y), shoulder buttons (two of which might be axes) and 3 buttons in the middle (Start, Back and usually some kind of logo-button).
	This includes devices that have a similar layout, like the Playstation DualShock Controller, but different button names; SDL_GameController uses the naming-conventions of xbox360/XInput for all supported devices, so you'll know that SDL_CONTROLLER_AXIS_LEFTX is always the X-Axis of the left Analog Stick, or SDL_CONTROLLER_BUTTON_B is always the rightmost buttons of the 4 buttons on the right, for example. This makes providing consistent input bindings (for this kind of device) to your users easy, like "press B to jump, move around with the left analog stick" - with SDL_Joystick (and the underlying APIs like DirectInput) it's impossible to know which SDL (or DirectInput) axis or button corresponds to which physical axis/button on the device.


	https://stackoverflow.com/questions/35385658/sdl2-going-too-fast-why-does-it-read-multiple-inputs-when-i-press-just-one-bu  Que solo se ejecute una vez al pulsar un botón y no múltiples veces

	https://books.google.es/books?id=VfxNDwAAQBAJ&pg=PT420&lpg=PT420&dq=detect+one+single+input+with+trigger+sdl&source=bl&ots=Dld8o4T2oj&sig=ACfU3U0Kcyj2sbkb2krTQQPQmDxvRZwNtA&hl=es&sa=X&ved=2ahUKEwj299ixg6vmAhVJD2MBHdphDdEQ6AEwBXoECAoQAQ#v=onepage&q=detect%20one%20single%20input%20with%20trigger%20sdl&f=false 	

	Datos sobre triggers, sticks, conectar y desconectar mandos mientras el juego se ejecuta
	-----------------------------------------------------------------------

	https://medium.com/@gayashanbc/explore-the-observer-design-pattern-with-c-8592459b0486


-----------CORRECCION DE LA PRACTICA----------------

1 Funcionamiento
El fuego va demasiado deprisa. No parece haber ""coherencia temporal"" entre un fotograma y el siguiente (o es difícil verla). Pasa también en PS4, aunque pongáis 30fps (FLIP_RATE a 1)
GRAVE Dependiendo de la resolución, no todo se llena con barras. En 1280x720 se queda un espacio sin ellas.
2 Estructura, abstracción y parámetros
GRAVE ¿Por qué Fire tiene un Update y Bars no? Mantenéis la posición en el bucle principal y se la pasáis al Draw*() en lugar de que lo guarden las barras.
Que PS4Renderer::Clear() llame a PutPixel() es un desastre para el rendimiento. En lo que se refiere a encapsulación tiene sentido, pero en este caso ocasiona un cuello de botella artificial, especialmente en modo tiled. Deberíais recorrer la memoria del display buffer directamente para no tener que tener que calcular continuamente la posición en memoria (y transformar el Color).
GRAVE No deberíais enlazar con SDLtest.lib. Ese nombre ¿no os da la idea de que sirve para comprobar que SDL funciona? ¿Por qué lo necesitáis en vuestra práctica?
3 Calidad del código
firePalette debería ser const (y que para Fuego también lo fuera). BarColor también.
4 Parte opcional
Sin hacer.


-------------11-12------------------

NO HACER EL INCLUDE EN .H SI ES POR UN PUNTERO. HACER DECLARACION PREDEFINIDA.
NUNCA METER CODIGO EN EL .H
-SOLO TEMPLATES Y FUNCIONES INLINE (GETTER Y SETTER)
-NO USAR DEFINES PARA CONSTANTES
-	-VARIABLE ESTÁTICA CONST.

-USAR CONST PARA PROTEGERSE DE LOS MALOS USOS.
-USAR ASSERT.

COHERENCIA TEMPORAL -> RECOMIENDA QUE LA IMPLEMENTACION LA METAMOS EN EL "SISTEMA DE ENTIDAD" SI TNEMOS PUERTA, CADA ENTIDAD RECUERDE CUANDO FUE LA ULTIMA VEZ QUE CAMBIO SU ESTADO
"OYE ABRETE" MARCA EL INSTANTE, COMO LA VERSION PINTADA ESTA SUCIA Y TENGO QUE VOLVER A ...
TENEMOS UN CONTADOR DE NUMEROS DE FRAMES A PINTAR PARA PINTAR EL ULTIMO ESTADO Y AL MODIFICAR EL ESTADO "EMPIEZA A ABRIRTE" O LO QUE SEA, EL CONTADOR SE PONGA EN DONDE TOQUE
SI EL NUMERO DEL INDICE NO ES 0 SE PINTA Y SE RESTAURA

LA ENTIDAD TIENE UN METODO RENDER

------------------

Algunos TODO:
-PlatformPC.h.
	-Utilizamos vector.
-PlatformPC.cpp.
	-BigEndian. Crear metodo

-Input.h.
	-Init.Texture filtering
	-Observer. Es putero?????

-Dollar.cpp
	-TODO: Renderer::GetNumBuffers(). Variable estatica????
	//TODO: SE PINTA MAS VECES DE LAS NECESARIAS AL INICIO
	-Dollar si recibes mas de 1, tambien se hace animacion
	
En todo: 
-Parametros const & ????????
-Atributos que se usan todo el rato declarados en la clase?????????
-CERRAR LA VENTANA CON LA 'X' no funcionaç
-ctrl + k + d
-no se donde va rect.h
-RendererThread. Me ha dado perezota
-FrameRate esta mal. Va demasiado rapido